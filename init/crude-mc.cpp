/**
 * @file crude-mc.cpp
 * @author TÃ©o Sobrino
 * @brief A very rudimentary crude version of a monte carlo process to find
 * an approximate value of pi:
 * We generate a pair of random numbers p = (x,y) in [0, 1), this represents
 * any point in the unit square, we can imagine a quarter circumnference 
 * drawn in this square, if a point is inside of it, we increase a counter
 * (n_in) if we use many points (N), this is roughly the area of the circle, as 
 * A = pi*r -> pi = A/r -> pi = 4*(n_in/N)
 *
 *  @version 1.0
 * @date 2024-04-23
 * 
 * @copyright Copyright (c) 2024
 * 
 */

#include <random>
#include <iostream>

bool is_inside_circle(double x, double y)
{
    return (x*x + y*y) <= 1 ? true : false; 
}

int main (int argc, char *argv[]) {

    std::random_device rd;
    std::mt19937 gen1(rd());
    std::mt19937 gen2(rd());
    std::mt19937 gen3(rd());

    std::uniform_real_distribution<double> u01dist(0,1);

    //using two pairs one generated by the same sequence, one where x
    //is sampled from a sequence and y from another.

    double x1, y1, x2, y2;
    
    int n_in1 = 0;
    int n_in2 = 0;

    int N = 1000000;
    for (int i = 0; i < N; i++)
    {
        x1 = u01dist(gen1);
        y1 = u01dist(gen1);
        if( is_inside_circle(x1, y1))  n_in1++;
        
        x2 = u01dist(gen2);
        y2 = u01dist(gen3);
        if( is_inside_circle(x2, y2))  n_in2++;
    }

    double pi1 = 0;
    double pi2 = 0;

    pi1 = 4*((double)n_in1)/N;
    pi2 = 4*((double)n_in2)/N;

    printf("Pi_1 = %lf, Pi_2 = %lf\n", pi1, pi2);

    return 0;
}
